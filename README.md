# Every Matrix

### 1.针对反馈意见的修改
```
1.ApiResult, SessionResp让所有响应均不符合要求
去掉这两个类,对结果不再进行json包装

2.routePrefix让所有请求URL均不符合要求
a).去掉routePrefix,使路由完全匹配PDF
b).调整项目端口为8001,与PDF完成匹配

3.workPool未使用,pool本身是否过渡包装
a).本意workPool是给比较重的任务异步执行的,但是目前确实没有用到的场景,去掉它
b).pool是否过渡包装?有一点,我是因为不清楚这个项目想在哪些细节上考察,所有可以引伸的地方都尽量引伸了一下,既然这不是考察点,则去掉

4.大部分项目集中在DispatcherHandler里,没有按功能模块进行拆分
考虑接口较为简单,所以直接在里去私有方法处理了,那么对于这三个接口,拆分两个类分别管理Session和Stake

5.未对customerToSessionCache进行清理
由于BidirectionalCache只在读在过程中清理过期key,在长期的运行过程中,如果大量的请求只申请sessionKey但不读取,确实容易造成这些key常驻内存,尽量每个key占用空间不大,但量积累后还是可能会造成较
为严重的内存泄漏,之前没有处理原因有两点:
a).以为demo重点是考虑如何在最合适的时间复杂度和空间复杂度上不依赖第三方组件去解决这个问题(已达到)
b).如果读时清理key不够,写时不可能去对整个cache进行清理(太慢),那么只能用定时任务清理,这个清理需要每次遍历两个map去比较时间,消耗较大,定时任务频率不好控制

解决办法:
最常用的解决办法是采用定时任务去遍历两个map去清理,但是每次扫描这两个map然后去清理,频率不好控制,扫描两个map的全部数据消耗也过大,那么我们可以换一个思路,假设要扫描的数据是一个已经按过期时间排好
序的结构,小的在前,应该更早过期,这样就可以优化,其中有三个优化点:
a).不需要遍历两个map,只需要遍历其中一个,如果正向cache过期了,那么其反向cache也应该删除
b).不需要完全遍历map,只需要遍历到当前系统时间(毫秒数) - 遍历时map的过期时间 < 10 * 60 * 1000即可停止,因为我们数据是排好序的,达到这个条件,说明当前遍历的值还未过期,那么该值之后的值肯定不会
过期,没有必要继续遍历
c).如果可以接受即使过期,依然允许适当延时,我觉得这个扫描线程可以适当休眠,而不是一直执行,比如休眠5秒,然后整体删除过去5秒内的所有过期key(因为我们还有读取时删除这一重保障),定时任务删除的往往是没
有人用的key,是可以接受的
以上实现的前提条件,是需要我们的map是一个有序的容器,而不能只是一个散列表,所以LinkedHashMap就很合适,因为其不是线程安全的,所以需要考虑线程安全问题,另外,由于只需要遍历一个map,所以正向cache和
反向cache中,任取一个变更为LinkedHashMap即可,我这里就将正向cache变更为LinkedHashMap

6.bettingMap的值不是线程安全的
是的,虽然ConcurrentHashMap对单个的读/写操作提供了线程安全的保证,但对于复合操作,如先检查键是否存在,然后再根据结果进行插入或删除操作,需要额外的同步,这里的使用,确实是这种场景,是我疏忽了,这里
我会手动对这块代码进行同步

7.stake数据的存储不能满足程序长时间运行的要求
随着程序的运行,bettingMap确实会膨胀,由于不允许写文件或数据库,有两点优化方向(能减缓膨胀速度,但是数据总体依然是膨胀的):
1.改进数据存储方式,其List<StakeInfo>中的StakeInfo改为字符串,形式为customerId:stake值,这样可以节约不少内存
2.对于同customerId,同betOfferId,同stake的重新投标,过滤掉
```

### 2.业务理解
```
1.三个接口(以下简称A/B/C):
    A:获取某个用户的sessionKey,过期时间为10分钟,10分钟内重复请求返回相同的sessionKey,10分钟后则生成另外一个sessionKey
    B:为某个betOfferId去提交某个用户的stake,我的理解这里像招标一样,为某个项目(betOfferId为其标识ID),每个人可以投标,投标时并非用自己的ID而是用自己用A接口拿到的sessionKey,每个用户可以
    为该标多次投标
    C:获取某个betOfferId的最高前20个投标人及出价的csv,投标人不能重复,sessionKey过期时,当时的投标信息不能删除
    
2.实现机制:
    A需求分析:
    为某个customerId要生成对应的sessionKey,过期时间为10分钟,在后面B/C的操作中,需要用sessionKey执行操作,再找到对应的customerId,所以这里要求我们用最快的速度能够根据customerId找到
    sessionKey,也需要我们能够最快地通过sessionKey找到customerId,并且能够设置过期时间
    
    A实现(cache.BidirectionalCache):
    1.需要最快地用一个值找到另一个值,最快的方式自然是散列表,只需要O(1)的时间复杂度,由于需要通过额外的线程去清理过期key,为了配合这个线程更高效地工作,我们使用LinkedHashMap,以上有写明原因
    2.除了能够通过key快速找value,还需要能通过value快速找key,所以我们需要一个额外的ConcurrentHashMap去存储反向的值,这个就不需要LinkedHashMap了
    3.需要设置过期时间,那么我们存的值应该是一个对象,对象里除了应该有要存的值,还应该有存储的时间,在读取数据的时候,判断是否过期,若是,则应该从两个map中把对应的数据删除再返回null
    
    B需求分析:
    为某个标书(betOfferId),每个人可以携带自己的sessionKey进行多次投标,所以信息都需要记录
    
    B实现:
    1.为某个标书记录每个人的所有投标,首先我们需要一个散列表,以O(1)的速度找到对应的标书,其次对于找到的标书,我们需要一个额外的结构去纪录所有人对这个标书的投标,这里将标书散列表的一个值视为一个
    插槽,每个插槽后面可以指向一个结构去存储对应的投标纪录,这个结构可以是链表或者数组,甚至跳表或红黑树,为了节省内存(可以省掉各种指针的占用空间,也不多),我这里选择Java的List结构,只是这样需要
    更多连续的内存
    2.每次一次投标,相当于找到该标书对应的插槽后,为插槽指向的数据结构处将投标信息纪录,之前的方案把每次的投标信息存储成一个稳定的结构(model.StakeInfo),采用对象的方式,内存消耗较大,这里改进为
    存储为一个字符串,其形式为customerId:stake,betOfferId就不用再记录在里面,因为槽上有这个值,后期有需求需要对其排序,这时候可以把该槽的数据解析成一个对象再操作(会稍微多消耗一些CPU)
    
    C需求分析:
    获取某个标书的最高前20个投标人及出价的csv,投标人不能重复,sessionKey过期时,当时的投标信息不能删除
    
    C实现:
    1.获取最高前20,就需要我们对某个标书插槽指向的数据,也就是List<StakeInfo>根据stake的值进行排序,这里排序使用原生sort方法即可实现,我不清楚这里要不要考算法,既然有简便的方法,我也就没有画
    蛇添足,但如果要分析,对这个结构使用什么算法排比较合适,倒是可以聊聊:
        多人投标,每人可以多次,这个List的size的大小实际上线中可能不小,所以像冒泡/插入/选择排序就应该尽量避免,因为他们的时间复杂度为O(n^2),那么其他排序算法,最好的时间复杂度就是O(nlogn)算
        法,比如归并排序,快速排序,堆排序,而题目要求我们尽量节省内存,那么归并排序可以排除,因为其需要O(n)的空间,对于快速排序和堆排序,由于快速排序对于数据交换的次数少于堆排序,所以快速排序效率
        更高,是最好的选择,至于快速排序是不稳定的排序算法(对于相同的值顺序不能保证,有可能会交换位置),这个题目没有要求,不算劣势
    2.由于List<StakeInfo>的一部分数据已经被持久化到文件中,所以需要取出该槽的StakeInfo,与现有的数据合并,再进行排序
    3.这样排序还不够,因为某个用户可能会重复出价,点据前20名的多个位置,所以需要对用户ID进行判重,每个用户只取最高出价,从排序后的数组中拿出满足条件的前20个customer信息即可
```

### 3.使用方式
```
A接口(GET):
http://127.0.0.1:8001/{customerid}/session

B接口(POST):
http://127.0.0.1:8001/{betofferid}/stake?sessionkey={sessionkey}

C接口(GET)
http://127.0.0.1:8001/{betofferid}/highstakes
```

### 4.关于打包
```
由于项目没有使用任何包管理工具,打包所有java类时由于互相依赖,手动打包很难维护这些依赖,所以使用Makefile来进行维护,该Makefile中定义了四条命令:
1.all: 执行build,package,run三种操作,会自动将项目编译,然后打包成jar包(文件名为stake.jar,在Makefile中定义),最后会运行该jar包
2.build: 只执行build命令,会将项目编译
3.package: 只执行打包命令,会将项目打包成jar包(前提是out已经存在编译后的文件)
4.run: 只执行启动命令,会将该jar包运行

在该项目的根目录下,在命令行直接运行make即可一条龙执行所有命令,如果有其他需要可以make build/make package/make run
```