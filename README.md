# Every Matrix

### 1.Http服务整体思路
请求流转图如下:
<img src="https://github.com/somno1ency/every-matrix/blob/main/request.png">
```
1.线程池分两种,一种为http线程池,主要用来做http流量的路由匹配及转发,以及转发之后的轻量级操作,CPU运算消耗不大,主要是IO密集,所以这里线程池可以设置得大一些来支持更高的并发,另一种为工作线程池,
主要用来执行重度操作,目前该项目实际上没有用到,只是提前定义了
2.DispatcherHandler为全局路由分发者,这里做路由匹配后将请求转发到不同的控制器去处理,该项目只有三个接口,由于最简化原则,就没有抽象出controller层去独立处理请求,而是直接在DispatcherHandler
中使用私有方法进行了处理
3.service为具体操作逻辑,比如数据库的操作,与第三方交互的操作等等,由于最简化原则,没有抽象出独立的service层进行处理,而是在DispatcherHandler中使用私有方法进行了处理
4.PDF要求返回原始字符串即可,比如sessionKey,我这儿对返回结果额外做了下包装,采用的code/msg的机制,不知是否画蛇添足?
```

### 2.业务理解
```
1.三个接口(以下简称A/B/C):
    A:获取某个用户的sessionKey,过期时间为10分钟,10分钟内重复请求返回相同的sessionKey,10分钟后则生成另外一个sessionKey
    B:为某个betOfferId去提交某个用户的stake,我的理解这里像招标一样,为某个项目(betOfferId为其标识ID),每个人可以投标,投标时并非用自己的ID而是用自己用A接口拿到的sessionKey,每个用户可以为该
    标多次投标
    C:获取某个betOfferId的最高前20个投标人及出价的csv,投标人不能重复,sessionKey过期时,当时的投标信息不能删除
    
2.实现机制:
    A需求分析:
    为某个customerId要生成对应的sessionKey,过期时间为10分钟,在后面B/C的操作中,需要用sessionKey执行操作,再找到对应的customerId,所以这里要求我们用最快的速度能够根据customerId找到sessionKey,
    也需要我们能够最快地通过sessionKey找到customerId,并且能够设置过期时间
    
    A实现(cache.BidirectionalCache):
    1.需要最快地用一个值找到另一个值,最快的方式自然是散列表,只需要O(1)的时间复杂度,这里要考虑并发操作,所以我们使用ConcurrentHashMap
    2.除了能够通过key快速找value,还需要能通过value快速找key,所以我们需要一个额外的ConcurrentHashMap去存储反向的值
    3.需要设置过期时间,那么我们存的值应该是一个对象,对象里除了应该有要存的值,还应该有存储的时间,在读取数据的时候,判断是否过期,若是,则应该从两个map中把对应的数据删除再返回null
    
    B需求分析:
    为某个标书(betOfferId),每个人可以携带自己的sessionKey进行多次投标,所以信息都需要记录
    
    B实现:
    1.为某个标书记录每个人的所有投标,首先我们需要一个散列表,以O(1)的速度找到对应的标书,其次对于找到的标书,我们需要一个额外的结构去纪录所有人对这个标书的投标,这里将标书散列表的一个值视为一个插槽,
    每个插槽后面可以指向一个结构去存储对应的投标纪录,这个结构可以是链表或者数组,甚至跳表或红黑树,为了节省内存(可以省掉各种指针的占用空间,也不多),我这里选择Java的List结构,只是这样需要更多连续的内存
    2.每次一次投标,相当于找到该标书对应的插槽后,为插槽指向的数据结构处将投标信息纪录,每次的投标信息将其抽象成一个稳定的结构(model.StakeInfo),后期还需要对其排序
    
    C需求分析:
    获取某个标书的最高前20个投标人及出价的csv,投标人不能重复,sessionKey过期时,当时的投标信息不能删除
    
    C实现:
    1.获取最高前20,就需要我们对某个标书插槽指向的数据,也就是List<StakeInfo>根据stake的值进行排序,这里排序使用原生sort方法即可实现,我不清楚这里要不要考算法,既然有简便的方法,我也就没有画蛇添足,
    但如果要分析,对这个结构使用什么算法排比较合适,倒是可以聊聊:
        多人投标,每人可以多次,这个List的size的大小实际上线中可能不小,所以像冒泡/插入/选择排序就应该尽量避免,因为他们的时间复杂度为O(n^2),那么其他排序算法,最好的时间复杂度就是O(nlogn)算法,
    比如归并排序,快速排序,堆排序,而题目要求我们尽量节省内存,那么归并排序可以排除,因为其需要O(n)的空间,对于快速排序和堆排序,由于快速排序对于数据交换的次数少于堆排序,所以快速排序效率更高,是最好的选择,至于
    快速排序是不稳定的排序算法(对于相同的值顺序不能保证,有可能会交换位置),这个题目没有要求,不算劣势
    2.这样排序还不够,因为某个用户可能会重复出价,点据前20名的多个位置,所以需要对用户ID进行判重,每个用户只取最高出价,从排序后的数组中拿出满足条件的前20个customer信息即可
```

### 3.使用方式
```
A接口(GET):
http://127.0.0.1:8000/app/v1/{customerId}/session

B接口(POST):
http://127.0.0.1:8000/app/v1/{betOfferId}/stake?sessionKey={sessionKey}

C接口(GET)
http://127.0.0.1:8000/app/v1/{betOfferId}/highstakes
```