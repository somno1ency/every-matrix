package com.everymatrix.stake.cache;

import java.util.Iterator;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * @author mackay.zhou
 * created at 2024/12/12
 */
public class BidirectionalCache<K, V> {

    // quickly find sessionKey for customerId, we need a map, which time complex is O(1), and we need to consider multiple thread scene, so use the ConcurrentHashMap
    private final ConcurrentHashMap<K, CacheEntry<V>> cache = new ConcurrentHashMap<>();

    // quickly find customerId for sessionKey, we need a reversed map
    private final ConcurrentHashMap<V, CacheEntry<K>> reverseCache = new ConcurrentHashMap<>();

    private final long expirationMillis;

    public BidirectionalCache(long expirationMillis) {
        this.expirationMillis = expirationMillis;
    }

    public void put(K key, V value) {
        CacheEntry<V> entry = new CacheEntry<>(value);
        cache.put(key, entry);

        // we can only remove when reading, if we set a same key multiple times, only one element will be store in cache, but will be store multiple element in reverseCache as every value
        // is different(generated by StringUtil.genUniqueId), so we need to clean to avoid memory leak
        // pay attention: no need to cost time to do this, we can return the same sessionKey rather than generate a new one if not expire
        // reverseCache.entrySet().removeIf(currentEntry -> currentEntry.getValue().value.equals(key));
        CacheEntry<K> reverseEntry = new CacheEntry<>(key);
        reverseCache.put(value, reverseEntry);
    }

    public V getValueByKey(K key) {
        CacheEntry<V> entry = cache.get(key);
        if (entry == null) {
            return null;
        }

        if (System.currentTimeMillis() - entry.createdTime > expirationMillis) {
            cache.remove(key);
            reverseCache.remove(entry.value);

            return null;
        }

        return entry.value;
    }

    public K getKeyByValue(V value) {
        CacheEntry<K> entry = reverseCache.get(value);
        if (entry == null) {
            return null;
        }

        if (System.currentTimeMillis() - entry.createdTime > expirationMillis) {
            cache.remove(entry.value);
            reverseCache.remove(value);

            return null;
        }

        return entry.value;
    }

    static class CacheEntry<T> {

        T value;

        long createdTime;

        public CacheEntry(T value) {
            this.value = value;
            this.createdTime = System.currentTimeMillis();
        }
    }
}
